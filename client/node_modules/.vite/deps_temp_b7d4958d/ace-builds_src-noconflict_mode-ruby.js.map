{
  "version": 3,
  "sources": ["../../ace-builds/src-noconflict/mode-ruby.js"],
  "sourcesContent": ["ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token: \"constant.other.symbol.ruby\",\n    regex: \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\nexports.qString = {\n    token: \"string\",\n    regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\nexports.qqString = {\n    token: \"string\",\n    regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\nexports.tString = {\n    token: \"string\",\n    regex: \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\nvar constantNumericHex = exports.constantNumericHex = {\n    token: \"constant.numeric\",\n    regex: \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\nvar constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n};\nvar constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n};\nvar constantNumericOctal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n};\nvar constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\",\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n};\nvar constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\",\n    regex: /\\b([\\d]i)\\b/\n};\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token: \"constant.numeric\",\n    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n};\nvar instanceVariable = exports.instanceVariable = {\n    token: \"variable.instance\",\n    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\nvar RubyHighlightRules = function () {\n    var builtinFunctions = (\"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" +\n        \"private_class_method|remove_method|undef_method\");\n    var keywords = (\"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\");\n    var buildinConstants = (\"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\");\n    var builtinVariables = (\"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\");\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n    var closeParen = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"<\": \">\",\n        \"^\": \"^\",\n        \"|\": \"|\",\n        \"%\": \"%\"\n    };\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"comment.multiline\",\n                regex: \"^=begin(?=$|\\\\s.*$)\",\n                next: \"comment\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/](?=.*\\/)/,\n                next: \"regex\"\n            },\n            [{\n                    token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                    regex: /(:)?(\")/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: escapedChars\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /\"/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\",\n                    regex: /`/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: escapedChars\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /`/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                    regex: /(:)?(')/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: /\\\\['\\\\]/\n                        }, {\n                            token: \"string.end\",\n                            regex: /'/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\",\n                    regex: /%[qwx]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"qStateWithoutInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"string.start\",\n                    regex: /%[QWX]?([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"qStateWithInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"constant.other.symbol.ruby\",\n                    regex: /%[si]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"sStateWithoutInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"constant.other.symbol.ruby\",\n                    regex: /%[SI]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"sStateWithInterpolation\";\n                        return this.token;\n                    }\n                }, {\n                    token: \"string.regexp\",\n                    regex: /%[r]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                        if (stack.length)\n                            stack = [];\n                        var paren = val[val.length - 1];\n                        stack.unshift(paren, state);\n                        this.next = \"rState\";\n                        return this.token;\n                    }\n                }],\n            {\n                token: \"punctuation\",\n                regex: \"::\"\n            },\n            instanceVariable,\n            {\n                token: \"variable.global\",\n                regex: \"[$][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\",\n                regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n            }, {\n                token: [\"punctuation.operator\", \"support.function\"],\n                regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n            }, {\n                token: [\"punctuation.operator\", \"identifier\"],\n                regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n            }, {\n                token: \"string.character\",\n                regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /\\?(?=.+:)/\n            },\n            constantNumericRational,\n            constantNumericComplex,\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n            constantNumericBinary,\n            constantNumericDecimal,\n            constantNumericOctal,\n            {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = (value[2] == '-' || value[2] == '~') ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        { type: \"constant\", value: tokens[1] },\n                        { type: \"string\", value: tokens[2] },\n                        { type: \"support.class\", value: tokens[3] },\n                        { type: \"string\", value: tokens[4] }\n                    ];\n                },\n                regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }],\n                    indentedHeredoc: [{\n                            token: \"string\",\n                            regex: \"^ +\"\n                        }, {\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function (currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            }, {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\",\n                onMatch: function (value, currentState, stack) {\n                    this.next = '';\n                    if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n                        stack.shift();\n                        this.next = stack.shift();\n                    }\n                    return this.token;\n                }\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.multiline\",\n                regex: \"^=end(?=$|\\\\s.*$)\",\n                next: \"start\"\n            }, {\n                token: \"comment\",\n                regex: \".+\"\n            }\n        ],\n        \"qStateWithInterpolation\": [{\n                token: \"string.start\",\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"string\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: escapedChars\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"string.end\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"string\";\n                }\n            }, {\n                defaultToken: \"string\"\n            }],\n        \"qStateWithoutInterpolation\": [{\n                token: \"string.start\",\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"string\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\['\\\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"string.end\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"string\";\n                }\n            }, {\n                defaultToken: \"string\"\n            }],\n        \"sStateWithoutInterpolation\": [{\n                token: \"constant.other.symbol.ruby\",\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                defaultToken: \"constant.other.symbol.ruby\"\n            }],\n        \"sStateWithInterpolation\": [{\n                token: \"constant.other.symbol.ruby\",\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                token: \"constant.language.escape\",\n                regex: escapedChars\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\./\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"constant.other.symbol.ruby\",\n                regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.other.symbol.ruby\";\n                }\n            }, {\n                defaultToken: \"constant.other.symbol.ruby\"\n            }],\n        \"rState\": [{\n                token: \"string.regexp\",\n                regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                    if (stack.length && val === stack[0]) {\n                        stack.unshift(val, state);\n                        return this.token;\n                    }\n                    return \"constant.language.escape\";\n                }\n            }, {\n                token: \"paren.start\",\n                regex: /#{/,\n                push: \"start\"\n            }, {\n                token: \"string.regexp\",\n                regex: /\\//\n            }, {\n                token: \"string.regexp\",\n                regex: /[)\\]>}^|%][imxouesn]*/, onMatch: function (val, state, stack) {\n                    if (stack.length && val[0] === closeParen[stack[0]]) {\n                        stack.shift();\n                        this.next = stack.shift();\n                        return this.token;\n                    }\n                    this.next = '';\n                    return \"constant.language.escape\";\n                }\n            },\n            { include: \"regex\" },\n            {\n                defaultToken: \"string.regexp\"\n            }],\n        \"regex\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\[AGbBzZ]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\g<[a-zA-Z0-9]*>/\n            }, {\n                token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n            }, {\n                token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)([^/]*)(})/\n            }, {\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/][imxouesn]*/,\n                next: \"start\"\n            }, {\n                token: \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"regexp.keyword\",\n                regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /&?&?\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"pop\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.characterclass\"\n            }\n        ]\n    };\n    this.normalizeRules();\n};\noop.inherits(RubyHighlightRules, TextHighlightRules);\nexports.RubyHighlightRules = RubyHighlightRules;\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar MatchingBraceOutdent = function () { };\n(function () {\n    this.checkOutdent = function (line, input) {\n        if (!/^\\s+$/.test(line))\n            return false;\n        return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n        if (!match)\n            return 0;\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({ row: row, column: column });\n        if (!openBracePos || openBracePos.row == row)\n            return 0;\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n}).call(MatchingBraceOutdent.prototype);\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n\n});\n\nace.define(\"ace/mode/folding/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar FoldMode = exports.FoldMode = function () {\n};\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            }\n            else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            }\n            else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        }\n        else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        }\n        else\n            return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n        var stack = [val];\n        if (!dir)\n            return;\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                }\n                else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n                if (level > 0) {\n                    stack.unshift(token.value);\n                }\n                else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n        if (!token)\n            return null;\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            }\n            else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        }\n        else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/folding/ruby\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\nvar Mode = function () {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \"#\";\n    this.getNextLineIndent = function (state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n        return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n    this.getMatching = function (session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/ruby\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "],
  "mappings": "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",
  "names": ["require", "exports", "module"]
}
